{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define(t) : (e = \"undefined\" != typeof globalThis ? globalThis : e || self).firebase = t();\n}(this, function () {\n  \"use strict\";\n\n  var _r = function r(e, t) {\n    return (_r = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (e, t) {\n      e.__proto__ = t;\n    } || function (e, t) {\n      for (var r in t) {\n        t.hasOwnProperty(r) && (e[r] = t[r]);\n      }\n    })(e, t);\n  };\n\n  var _a = function a() {\n    return (_a = Object.assign || function (e) {\n      for (var t, r = 1, n = arguments.length; r < n; r++) {\n        for (var i in t = arguments[r]) {\n          Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);\n        }\n      }\n\n      return e;\n    }).apply(this, arguments);\n  };\n\n  function e(e, a, s, l) {\n    return new (s = s || Promise)(function (r, t) {\n      function n(e) {\n        try {\n          o(l.next(e));\n        } catch (e) {\n          t(e);\n        }\n      }\n\n      function i(e) {\n        try {\n          o(l.throw(e));\n        } catch (e) {\n          t(e);\n        }\n      }\n\n      function o(e) {\n        var t;\n        e.done ? r(e.value) : ((t = e.value) instanceof s ? t : new s(function (e) {\n          e(t);\n        })).then(n, i);\n      }\n\n      o((l = l.apply(e, a || [])).next());\n    });\n  }\n\n  function n(r, n) {\n    var i,\n        o,\n        a,\n        s = {\n      label: 0,\n      sent: function sent() {\n        if (1 & a[0]) throw a[1];\n        return a[1];\n      },\n      trys: [],\n      ops: []\n    },\n        e = {\n      next: t(0),\n      throw: t(1),\n      return: t(2)\n    };\n    return \"function\" == typeof Symbol && (e[Symbol.iterator] = function () {\n      return this;\n    }), e;\n\n    function t(t) {\n      return function (e) {\n        return function (t) {\n          if (i) throw new TypeError(\"Generator is already executing.\");\n\n          for (; s;) {\n            try {\n              if (i = 1, o && (a = 2 & t[0] ? o.return : t[0] ? o.throw || ((a = o.return) && a.call(o), 0) : o.next) && !(a = a.call(o, t[1])).done) return a;\n\n              switch (o = 0, a && (t = [2 & t[0], a.value]), t[0]) {\n                case 0:\n                case 1:\n                  a = t;\n                  break;\n\n                case 4:\n                  return s.label++, {\n                    value: t[1],\n                    done: !1\n                  };\n\n                case 5:\n                  s.label++, o = t[1], t = [0];\n                  continue;\n\n                case 7:\n                  t = s.ops.pop(), s.trys.pop();\n                  continue;\n\n                default:\n                  if (!(a = 0 < (a = s.trys).length && a[a.length - 1]) && (6 === t[0] || 2 === t[0])) {\n                    s = 0;\n                    continue;\n                  }\n\n                  if (3 === t[0] && (!a || t[1] > a[0] && t[1] < a[3])) {\n                    s.label = t[1];\n                    break;\n                  }\n\n                  if (6 === t[0] && s.label < a[1]) {\n                    s.label = a[1], a = t;\n                    break;\n                  }\n\n                  if (a && s.label < a[2]) {\n                    s.label = a[2], s.ops.push(t);\n                    break;\n                  }\n\n                  a[2] && s.ops.pop(), s.trys.pop();\n                  continue;\n              }\n\n              t = n.call(r, s);\n            } catch (e) {\n              t = [6, e], o = 0;\n            } finally {\n              i = a = 0;\n            }\n          }\n\n          if (5 & t[0]) throw t[1];\n          return {\n            value: t[0] ? t[1] : void 0,\n            done: !0\n          };\n        }([t, e]);\n      };\n    }\n  }\n\n  function d(e) {\n    var t = \"function\" == typeof Symbol && Symbol.iterator,\n        r = t && e[t],\n        n = 0;\n    if (r) return r.call(e);\n    if (e && \"number\" == typeof e.length) return {\n      next: function next() {\n        return e && n >= e.length && (e = void 0), {\n          value: e && e[n++],\n          done: !e\n        };\n      }\n    };\n    throw new TypeError(t ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  }\n\n  function u(e, t) {\n    var r = \"function\" == typeof Symbol && e[Symbol.iterator];\n    if (!r) return e;\n    var n,\n        i,\n        o = r.call(e),\n        a = [];\n\n    try {\n      for (; (void 0 === t || 0 < t--) && !(n = o.next()).done;) {\n        a.push(n.value);\n      }\n    } catch (e) {\n      i = {\n        error: e\n      };\n    } finally {\n      try {\n        n && !n.done && (r = o.return) && r.call(o);\n      } finally {\n        if (i) throw i.error;\n      }\n    }\n\n    return a;\n  }\n\n  function v(e, t) {\n    if (!(t instanceof Object)) return t;\n\n    switch (t.constructor) {\n      case Date:\n        return new Date(t.getTime());\n\n      case Object:\n        void 0 === e && (e = {});\n        break;\n\n      case Array:\n        e = [];\n        break;\n\n      default:\n        return t;\n    }\n\n    for (var r in t) {\n      t.hasOwnProperty(r) && (e[r] = v(e[r], t[r]));\n    }\n\n    return e;\n  }\n\n  var i = (t.prototype.wrapCallback = function (r) {\n    var n = this;\n    return function (e, t) {\n      e ? n.reject(e) : n.resolve(t), \"function\" == typeof r && (n.promise.catch(function () {}), 1 === r.length ? r(e) : r(e, t));\n    };\n  }, t);\n\n  function t() {\n    var r = this;\n    this.reject = function () {}, this.resolve = function () {}, this.promise = new Promise(function (e, t) {\n      r.resolve = e, r.reject = t;\n    });\n  }\n\n  var o,\n      s,\n      l,\n      c = \"FirebaseError\",\n      h = (o = Error, _r(s = f, l = o), s.prototype = null === l ? Object.create(l) : (p.prototype = l.prototype, new p()), f);\n\n  function p() {\n    this.constructor = s;\n  }\n\n  function f(e, t) {\n    var r = o.call(this, t) || this;\n    return r.code = e, r.name = c, Object.setPrototypeOf(r, f.prototype), Error.captureStackTrace && Error.captureStackTrace(r, y.prototype.create), r;\n  }\n\n  var y = (m.prototype.create = function (e) {\n    for (var t = [], r = 1; r < arguments.length; r++) {\n      t[r - 1] = arguments[r];\n    }\n\n    for (var n, i = t[0] || {}, o = this.service + \"/\" + e, a = this.errors[e], s = a ? (n = i, a.replace(g, function (e, t) {\n      var r = n[t];\n      return null != r ? String(r) : \"<\" + t + \"?>\";\n    })) : \"Error\", l = this.serviceName + \": \" + s + \" (\" + o + \").\", c = new h(o, l), u = 0, p = Object.keys(i); u < p.length; u++) {\n      var f = p[u];\n      \"_\" !== f.slice(-1) && (f in c && console.warn('Overwriting FirebaseError base field \"' + f + '\" can cause unexpected behavior.'), c[f] = i[f]);\n    }\n\n    return c;\n  }, m);\n\n  function m(e, t, r) {\n    this.service = e, this.serviceName = t, this.errors = r;\n  }\n\n  var g = /\\{\\$([^}]+)}/g;\n\n  function b(e, t) {\n    return Object.prototype.hasOwnProperty.call(e, t);\n  }\n\n  function w(e, t) {\n    var r = new E(e, t);\n    return r.subscribe.bind(r);\n  }\n\n  var E = (O.prototype.next = function (t) {\n    this.forEachObserver(function (e) {\n      e.next(t);\n    });\n  }, O.prototype.error = function (t) {\n    this.forEachObserver(function (e) {\n      e.error(t);\n    }), this.close(t);\n  }, O.prototype.complete = function () {\n    this.forEachObserver(function (e) {\n      e.complete();\n    }), this.close();\n  }, O.prototype.subscribe = function (e, t, r) {\n    var n,\n        i = this;\n    if (void 0 === e && void 0 === t && void 0 === r) throw new Error(\"Missing Observer.\");\n    void 0 === (n = function (e, t) {\n      if (\"object\" != typeof e || null === e) return !1;\n\n      for (var r = 0, n = t; r < n.length; r++) {\n        var i = n[r];\n        if (i in e && \"function\" == typeof e[i]) return !0;\n      }\n\n      return !1;\n    }(e, [\"next\", \"error\", \"complete\"]) ? e : {\n      next: e,\n      error: t,\n      complete: r\n    }).next && (n.next = _), void 0 === n.error && (n.error = _), void 0 === n.complete && (n.complete = _);\n    var o = this.unsubscribeOne.bind(this, this.observers.length);\n    return this.finalized && this.task.then(function () {\n      try {\n        i.finalError ? n.error(i.finalError) : n.complete();\n      } catch (e) {}\n    }), this.observers.push(n), o;\n  }, O.prototype.unsubscribeOne = function (e) {\n    void 0 !== this.observers && void 0 !== this.observers[e] && (delete this.observers[e], --this.observerCount, 0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this));\n  }, O.prototype.forEachObserver = function (e) {\n    if (!this.finalized) for (var t = 0; t < this.observers.length; t++) {\n      this.sendOne(t, e);\n    }\n  }, O.prototype.sendOne = function (e, t) {\n    var r = this;\n    this.task.then(function () {\n      if (void 0 !== r.observers && void 0 !== r.observers[e]) try {\n        t(r.observers[e]);\n      } catch (e) {\n        \"undefined\" != typeof console && console.error && console.error(e);\n      }\n    });\n  }, O.prototype.close = function (e) {\n    var t = this;\n    this.finalized || (this.finalized = !0, void 0 !== e && (this.finalError = e), this.task.then(function () {\n      t.observers = void 0, t.onNoObservers = void 0;\n    }));\n  }, O);\n\n  function O(e, t) {\n    var r = this;\n    this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = t, this.task.then(function () {\n      e(r);\n    }).catch(function (e) {\n      r.error(e);\n    });\n  }\n\n  function _() {}\n\n  var I = (N.prototype.setInstantiationMode = function (e) {\n    return this.instantiationMode = e, this;\n  }, N.prototype.setMultipleInstances = function (e) {\n    return this.multipleInstances = e, this;\n  }, N.prototype.setServiceProps = function (e) {\n    return this.serviceProps = e, this;\n  }, N);\n\n  function N(e, t, r) {\n    this.name = e, this.instanceFactory = t, this.type = r, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = \"LAZY\";\n  }\n\n  var L = \"[DEFAULT]\",\n      S = (R.prototype.get = function (e) {\n    void 0 === e && (e = L);\n    var t = this.normalizeInstanceIdentifier(e);\n\n    if (!this.instancesDeferred.has(t)) {\n      var r = new i();\n      this.instancesDeferred.set(t, r);\n\n      try {\n        var n = this.getOrInitializeService(t);\n        n && r.resolve(n);\n      } catch (e) {}\n    }\n\n    return this.instancesDeferred.get(t).promise;\n  }, R.prototype.getImmediate = function (e) {\n    var t = _a({\n      identifier: L,\n      optional: !1\n    }, e),\n        r = t.identifier,\n        n = t.optional,\n        i = this.normalizeInstanceIdentifier(r);\n\n    try {\n      var o = this.getOrInitializeService(i);\n      if (o) return o;\n      if (n) return null;\n      throw Error(\"Service \" + this.name + \" is not available\");\n    } catch (e) {\n      if (n) return null;\n      throw e;\n    }\n  }, R.prototype.getComponent = function () {\n    return this.component;\n  }, R.prototype.setComponent = function (e) {\n    var t, r;\n    if (e.name !== this.name) throw Error(\"Mismatching Component \" + e.name + \" for Provider \" + this.name + \".\");\n    if (this.component) throw Error(\"Component for \" + this.name + \" has already been provided\");\n    if (\"EAGER\" === (this.component = e).instantiationMode) try {\n      this.getOrInitializeService(L);\n    } catch (e) {}\n\n    try {\n      for (var n = d(this.instancesDeferred.entries()), i = n.next(); !i.done; i = n.next()) {\n        var o = u(i.value, 2),\n            a = o[0],\n            s = o[1],\n            l = this.normalizeInstanceIdentifier(a);\n\n        try {\n          var c = this.getOrInitializeService(l);\n          s.resolve(c);\n        } catch (e) {}\n      }\n    } catch (e) {\n      t = {\n        error: e\n      };\n    } finally {\n      try {\n        i && !i.done && (r = n.return) && r.call(n);\n      } finally {\n        if (t) throw t.error;\n      }\n    }\n  }, R.prototype.clearInstance = function (e) {\n    void 0 === e && (e = L), this.instancesDeferred.delete(e), this.instances.delete(e);\n  }, R.prototype.delete = function () {\n    return e(this, void 0, void 0, function () {\n      var t;\n      return n(this, function (e) {\n        switch (e.label) {\n          case 0:\n            return t = Array.from(this.instances.values()), [4, Promise.all(function () {\n              for (var e = [], t = 0; t < arguments.length; t++) {\n                e = e.concat(u(arguments[t]));\n              }\n\n              return e;\n            }(t.filter(function (e) {\n              return \"INTERNAL\" in e;\n            }).map(function (e) {\n              return e.INTERNAL.delete();\n            }), t.filter(function (e) {\n              return \"_delete\" in e;\n            }).map(function (e) {\n              return e._delete();\n            })))];\n\n          case 1:\n            return e.sent(), [2];\n        }\n      });\n    });\n  }, R.prototype.isComponentSet = function () {\n    return null != this.component;\n  }, R.prototype.getOrInitializeService = function (e) {\n    var t,\n        r = this.instances.get(e);\n    return !r && this.component && (r = this.component.instanceFactory(this.container, (t = e) === L ? void 0 : t), this.instances.set(e, r)), r || null;\n  }, R.prototype.normalizeInstanceIdentifier = function (e) {\n    return !this.component || this.component.multipleInstances ? e : L;\n  }, R);\n\n  function R(e, t) {\n    this.name = e, this.container = t, this.component = null, this.instances = new Map(), this.instancesDeferred = new Map();\n  }\n\n  var P,\n      A = (j.prototype.addComponent = function (e) {\n    var t = this.getProvider(e.name);\n    if (t.isComponentSet()) throw new Error(\"Component \" + e.name + \" has already been registered with \" + this.name);\n    t.setComponent(e);\n  }, j.prototype.addOrOverwriteComponent = function (e) {\n    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e);\n  }, j.prototype.getProvider = function (e) {\n    if (this.providers.has(e)) return this.providers.get(e);\n    var t = new S(e, this);\n    return this.providers.set(e, t), t;\n  }, j.prototype.getProviders = function () {\n    return Array.from(this.providers.values());\n  }, j);\n\n  function j(e) {\n    this.name = e, this.providers = new Map();\n  }\n\n  function C() {\n    for (var e = 0, t = 0, r = arguments.length; t < r; t++) {\n      e += arguments[t].length;\n    }\n\n    for (var n = Array(e), i = 0, t = 0; t < r; t++) {\n      for (var o = arguments[t], a = 0, s = o.length; a < s; a++, i++) {\n        n[i] = o[a];\n      }\n    }\n\n    return n;\n  }\n\n  var D,\n      F,\n      k = [];\n  (F = D = D || {})[F.DEBUG = 0] = \"DEBUG\", F[F.VERBOSE = 1] = \"VERBOSE\", F[F.INFO = 2] = \"INFO\", F[F.WARN = 3] = \"WARN\", F[F.ERROR = 4] = \"ERROR\", F[F.SILENT = 5] = \"SILENT\";\n\n  function T(e, t) {\n    for (var r = [], n = 2; n < arguments.length; n++) {\n      r[n - 2] = arguments[n];\n    }\n\n    if (!(t < e.logLevel)) {\n      var i = new Date().toISOString(),\n          o = B[t];\n      if (!o) throw new Error(\"Attempted to log a message with an invalid logType (value: \" + t + \")\");\n      console[o].apply(console, C([\"[\" + i + \"]  \" + e.name + \":\"], r));\n    }\n  }\n\n  var x,\n      H = {\n    debug: D.DEBUG,\n    verbose: D.VERBOSE,\n    info: D.INFO,\n    warn: D.WARN,\n    error: D.ERROR,\n    silent: D.SILENT\n  },\n      z = D.INFO,\n      B = ((P = {})[D.DEBUG] = \"log\", P[D.VERBOSE] = \"log\", P[D.INFO] = \"info\", P[D.WARN] = \"warn\", P[D.ERROR] = \"error\", P),\n      V = (Object.defineProperty(U.prototype, \"logLevel\", {\n    get: function get() {\n      return this._logLevel;\n    },\n    set: function set(e) {\n      if (!(e in D)) throw new TypeError('Invalid value \"' + e + '\" assigned to `logLevel`');\n      this._logLevel = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), U.prototype.setLogLevel = function (e) {\n    this._logLevel = \"string\" == typeof e ? H[e] : e;\n  }, Object.defineProperty(U.prototype, \"logHandler\", {\n    get: function get() {\n      return this._logHandler;\n    },\n    set: function set(e) {\n      if (\"function\" != typeof e) throw new TypeError(\"Value assigned to `logHandler` must be a function\");\n      this._logHandler = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(U.prototype, \"userLogHandler\", {\n    get: function get() {\n      return this._userLogHandler;\n    },\n    set: function set(e) {\n      this._userLogHandler = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), U.prototype.debug = function () {\n    for (var e = [], t = 0; t < arguments.length; t++) {\n      e[t] = arguments[t];\n    }\n\n    this._userLogHandler && this._userLogHandler.apply(this, C([this, D.DEBUG], e)), this._logHandler.apply(this, C([this, D.DEBUG], e));\n  }, U.prototype.log = function () {\n    for (var e = [], t = 0; t < arguments.length; t++) {\n      e[t] = arguments[t];\n    }\n\n    this._userLogHandler && this._userLogHandler.apply(this, C([this, D.VERBOSE], e)), this._logHandler.apply(this, C([this, D.VERBOSE], e));\n  }, U.prototype.info = function () {\n    for (var e = [], t = 0; t < arguments.length; t++) {\n      e[t] = arguments[t];\n    }\n\n    this._userLogHandler && this._userLogHandler.apply(this, C([this, D.INFO], e)), this._logHandler.apply(this, C([this, D.INFO], e));\n  }, U.prototype.warn = function () {\n    for (var e = [], t = 0; t < arguments.length; t++) {\n      e[t] = arguments[t];\n    }\n\n    this._userLogHandler && this._userLogHandler.apply(this, C([this, D.WARN], e)), this._logHandler.apply(this, C([this, D.WARN], e));\n  }, U.prototype.error = function () {\n    for (var e = [], t = 0; t < arguments.length; t++) {\n      e[t] = arguments[t];\n    }\n\n    this._userLogHandler && this._userLogHandler.apply(this, C([this, D.ERROR], e)), this._logHandler.apply(this, C([this, D.ERROR], e));\n  }, U);\n\n  function U(e) {\n    this.name = e, this._logLevel = z, this._logHandler = T, this._userLogHandler = null, k.push(this);\n  }\n\n  function M(t) {\n    k.forEach(function (e) {\n      e.setLogLevel(t);\n    });\n  }\n\n  var W,\n      G = ((x = {})[\"no-app\"] = \"No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()\", x[\"bad-app-name\"] = \"Illegal App name: '{$appName}\", x[\"duplicate-app\"] = \"Firebase App named '{$appName}' already exists\", x[\"app-deleted\"] = \"Firebase App named '{$appName}' already deleted\", x[\"invalid-app-argument\"] = \"firebase.{$appName}() takes either no argument or a Firebase App instance.\", x[\"invalid-log-argument\"] = \"First argument to `onLog` must be null or a function.\", x),\n      $ = new y(\"app\", \"Firebase\", G),\n      Y = \"@firebase/app\",\n      K = \"[DEFAULT]\",\n      J = ((W = {})[Y] = \"fire-core\", W[\"@firebase/analytics\"] = \"fire-analytics\", W[\"@firebase/auth\"] = \"fire-auth\", W[\"@firebase/database\"] = \"fire-rtdb\", W[\"@firebase/functions\"] = \"fire-fn\", W[\"@firebase/installations\"] = \"fire-iid\", W[\"@firebase/messaging\"] = \"fire-fcm\", W[\"@firebase/performance\"] = \"fire-perf\", W[\"@firebase/remote-config\"] = \"fire-rc\", W[\"@firebase/storage\"] = \"fire-gcs\", W[\"@firebase/firestore\"] = \"fire-fst\", W[\"fire-js\"] = \"fire-js\", W[\"firebase-wrapper\"] = \"fire-js-all\", W),\n      Z = new V(\"@firebase/app\"),\n      q = (Object.defineProperty(Q.prototype, \"automaticDataCollectionEnabled\", {\n    get: function get() {\n      return this.checkDestroyed_(), this.automaticDataCollectionEnabled_;\n    },\n    set: function set(e) {\n      this.checkDestroyed_(), this.automaticDataCollectionEnabled_ = e;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(Q.prototype, \"name\", {\n    get: function get() {\n      return this.checkDestroyed_(), this.name_;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Object.defineProperty(Q.prototype, \"options\", {\n    get: function get() {\n      return this.checkDestroyed_(), this.options_;\n    },\n    enumerable: !1,\n    configurable: !0\n  }), Q.prototype.delete = function () {\n    var t = this;\n    return new Promise(function (e) {\n      t.checkDestroyed_(), e();\n    }).then(function () {\n      return t.firebase_.INTERNAL.removeApp(t.name_), Promise.all(t.container.getProviders().map(function (e) {\n        return e.delete();\n      }));\n    }).then(function () {\n      t.isDeleted_ = !0;\n    });\n  }, Q.prototype._getService = function (e, t) {\n    return void 0 === t && (t = K), this.checkDestroyed_(), this.container.getProvider(e).getImmediate({\n      identifier: t\n    });\n  }, Q.prototype._removeServiceInstance = function (e, t) {\n    void 0 === t && (t = K), this.container.getProvider(e).clearInstance(t);\n  }, Q.prototype._addComponent = function (t) {\n    try {\n      this.container.addComponent(t);\n    } catch (e) {\n      Z.debug(\"Component \" + t.name + \" failed to register with FirebaseApp \" + this.name, e);\n    }\n  }, Q.prototype._addOrOverwriteComponent = function (e) {\n    this.container.addOrOverwriteComponent(e);\n  }, Q.prototype.checkDestroyed_ = function () {\n    if (this.isDeleted_) throw $.create(\"app-deleted\", {\n      appName: this.name_\n    });\n  }, Q);\n\n  function Q(e, t, r) {\n    var n,\n        i,\n        o = this;\n    this.firebase_ = r, this.isDeleted_ = !1, this.name_ = t.name, this.automaticDataCollectionEnabled_ = t.automaticDataCollectionEnabled || !1, this.options_ = v(void 0, e), this.container = new A(t.name), this._addComponent(new I(\"app\", function () {\n      return o;\n    }, \"PUBLIC\"));\n\n    try {\n      for (var a = d(this.firebase_.INTERNAL.components.values()), s = a.next(); !s.done; s = a.next()) {\n        var l = s.value;\n\n        this._addComponent(l);\n      }\n    } catch (e) {\n      n = {\n        error: e\n      };\n    } finally {\n      try {\n        s && !s.done && (i = a.return) && i.call(a);\n      } finally {\n        if (n) throw n.error;\n      }\n    }\n  }\n\n  q.prototype.name && q.prototype.options || q.prototype.delete || console.log(\"dc\");\n  var X = \"7.22.1\";\n\n  function ee(l) {\n    var c = {},\n        u = new Map(),\n        p = {\n      __esModule: !0,\n      initializeApp: function initializeApp(e, t) {\n        void 0 === t && (t = {});\n        {\n          \"object\" == typeof t && null !== t || (t = {\n            name: t\n          });\n        }\n        var r = t;\n        void 0 === r.name && (r.name = K);\n        var n = r.name;\n        if (\"string\" != typeof n || !n) throw $.create(\"bad-app-name\", {\n          appName: String(n)\n        });\n        if (b(c, n)) throw $.create(\"duplicate-app\", {\n          appName: n\n        });\n        var i = new l(e, r, p);\n        return c[n] = i;\n      },\n      app: f,\n      registerVersion: function registerVersion(e, t, r) {\n        var n,\n            i = null !== (n = J[e]) && void 0 !== n ? n : e;\n        r && (i += \"-\" + r);\n        var o = i.match(/\\s|\\//),\n            a = t.match(/\\s|\\//);\n\n        if (o || a) {\n          var s = ['Unable to register library \"' + i + '\" with version \"' + t + '\":'];\n          return o && s.push('library name \"' + i + '\" contains illegal characters (whitespace or \"/\")'), o && a && s.push(\"and\"), a && s.push('version name \"' + t + '\" contains illegal characters (whitespace or \"/\")'), void Z.warn(s.join(\" \"));\n        }\n\n        h(new I(i + \"-version\", function () {\n          return {\n            library: i,\n            version: t\n          };\n        }, \"VERSION\"));\n      },\n      setLogLevel: M,\n      onLog: function onLog(e, t) {\n        if (null !== e && \"function\" != typeof e) throw $.create(\"invalid-log-argument\", {\n          appName: name\n        });\n        !function (a, t) {\n          for (var e = 0, r = k; e < r.length; e++) {\n            !function (e) {\n              var o = null;\n              t && t.level && (o = H[t.level]), e.userLogHandler = null === a ? null : function (e, t) {\n                for (var r = [], n = 2; n < arguments.length; n++) {\n                  r[n - 2] = arguments[n];\n                }\n\n                var i = r.map(function (e) {\n                  if (null == e) return null;\n                  if (\"string\" == typeof e) return e;\n                  if (\"number\" == typeof e || \"boolean\" == typeof e) return e.toString();\n                  if (e instanceof Error) return e.message;\n\n                  try {\n                    return JSON.stringify(e);\n                  } catch (e) {\n                    return null;\n                  }\n                }).filter(function (e) {\n                  return e;\n                }).join(\" \");\n                t >= (null != o ? o : e.logLevel) && a({\n                  level: D[t].toLowerCase(),\n                  message: i,\n                  args: r,\n                  type: e.name\n                });\n              };\n            }(r[e]);\n          }\n        }(e, t);\n      },\n      apps: null,\n      SDK_VERSION: X,\n      INTERNAL: {\n        registerComponent: h,\n        removeApp: function removeApp(e) {\n          delete c[e];\n        },\n        components: u,\n        useAsService: function useAsService(e, t) {\n          if (\"serverAuth\" === t) return null;\n          return t;\n        }\n      }\n    };\n\n    function f(e) {\n      if (!b(c, e = e || K)) throw $.create(\"no-app\", {\n        appName: e\n      });\n      return c[e];\n    }\n\n    function h(r) {\n      var t,\n          e,\n          n,\n          i = r.name;\n      if (u.has(i)) return Z.debug(\"There were multiple attempts to register component \" + i + \".\"), \"PUBLIC\" === r.type ? p[i] : null;\n      u.set(i, r), \"PUBLIC\" === r.type && (n = function n(e) {\n        if (void 0 === e && (e = f()), \"function\" != typeof e[i]) throw $.create(\"invalid-app-argument\", {\n          appName: i\n        });\n        return e[i]();\n      }, void 0 !== r.serviceProps && v(n, r.serviceProps), p[i] = n, l.prototype[i] = function () {\n        for (var e = [], t = 0; t < arguments.length; t++) {\n          e[t] = arguments[t];\n        }\n\n        return this._getService.bind(this, i).apply(this, r.multipleInstances ? e : []);\n      });\n\n      try {\n        for (var o = d(Object.keys(c)), a = o.next(); !a.done; a = o.next()) {\n          var s = a.value;\n\n          c[s]._addComponent(r);\n        }\n      } catch (e) {\n        t = {\n          error: e\n        };\n      } finally {\n        try {\n          a && !a.done && (e = o.return) && e.call(o);\n        } finally {\n          if (t) throw t.error;\n        }\n      }\n\n      return \"PUBLIC\" === r.type ? p[i] : null;\n    }\n\n    return p.default = p, Object.defineProperty(p, \"apps\", {\n      get: function get() {\n        return Object.keys(c).map(function (e) {\n          return c[e];\n        });\n      }\n    }), f.App = l, p;\n  }\n\n  var te,\n      re = function e() {\n    var t = ee(q);\n    return t.INTERNAL = _a(_a({}, t.INTERNAL), {\n      createFirebaseNamespace: e,\n      extendNamespace: function extendNamespace(e) {\n        v(t, e);\n      },\n      createSubscribe: w,\n      ErrorFactory: y,\n      deepExtend: v\n    }), t;\n  }(),\n      ne = (ie.prototype.getPlatformInfoString = function () {\n    return this.container.getProviders().map(function (e) {\n      if (\"VERSION\" !== (null == (t = e.getComponent()) ? void 0 : t.type)) return null;\n      var t,\n          r = e.getImmediate();\n      return r.library + \"/\" + r.version;\n    }).filter(function (e) {\n      return e;\n    }).join(\" \");\n  }, ie);\n\n  function ie(e) {\n    this.container = e;\n  }\n\n  \"object\" == typeof self && self.self === self && void 0 !== self.firebase && (Z.warn(\"\\n    Warning: Firebase is already defined in the global scope. Please make sure\\n    Firebase library is only loaded once.\\n  \"), (te = self.firebase.SDK_VERSION) && 0 <= te.indexOf(\"LITE\") && Z.warn(\"\\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\\n    \"));\n  var oe = re.initializeApp;\n\n  re.initializeApp = function () {\n    for (var e = [], t = 0; t < arguments.length; t++) {\n      e[t] = arguments[t];\n    }\n\n    return function () {\n      try {\n        return \"[object process]\" === Object.prototype.toString.call(global.process);\n      } catch (e) {\n        return;\n      }\n    }() && Z.warn('\\n      Warning: This is a browser-targeted Firebase bundle but it appears it is being\\n      run in a Node environment.  If running in a Node environment, make sure you\\n      are using the bundle specified by the \"main\" field in package.json.\\n      \\n      If you are using Webpack, you can specify \"main\" as the first item in\\n      \"resolve.mainFields\":\\n      https://webpack.js.org/configuration/resolve/#resolvemainfields\\n      \\n      If using Rollup, use the rollup-plugin-node-resolve plugin and specify \"main\"\\n      as the first item in \"mainFields\", e.g. [\\'main\\', \\'module\\'].\\n      https://github.com/rollup/rollup-plugin-node-resolve\\n      '), oe.apply(void 0, e);\n  };\n\n  var ae,\n      se,\n      le = re;\n  (ae = le).INTERNAL.registerComponent(new I(\"platform-logger\", function (e) {\n    return new ne(e);\n  }, \"PRIVATE\")), ae.registerVersion(Y, \"0.6.11\", se), ae.registerVersion(\"fire-js\", \"\");\n  return le.registerVersion(\"firebase\", \"7.22.1\", \"app\"), le;\n});","map":null,"metadata":{},"sourceType":"script"}